---
id: architecture
title: 전체 아키텍처 — 도메인 → Task → Skills
sidebar_label: 01. 전체 아키텍처
---

# 전체 아키텍처 — 도메인 → Task → Skills

RAP(Rapid Agentic Programming) 방식의 핵심은 **작업을 구조화**하는 것이다.
"AI한테 던지면 뭔가 나오겠지"가 아니라, 도메인을 명확히 나누고 각 레이어에서 최적의 도구를 사용한다.

---

## 1. 전체 구조 개요

```
전체 프로젝트
├── 도메인 A  →  Task A1, A2, A3
│                   └── SDD 기반 문서 (skills를 이용한 세부문서 생성) -> Like Subagents 로 개발 처리
├── 도메인 B  →  Task B1, B2
│                   └── SDD 기반 문서 (skills를 이용한 세부문서 생성) -> Like Subagents 로 개발 처리
└── 도메인 C  →  Task C1
                    └── SDD 기반 문서 (skills를 이용한 세부문서 생성) -> Like Subagents 로 개발 처리
```

**도메인**: 프로젝트에서 독립적으로 구분되는 기능 영역 (예: 인증, 결제, 알림)
**Task**: 도메인 내에서 실행 가능한 작업 단위
**Skills**: Task를 수행하기 위한 프롬프트 템플릿 + 컨텍스트

---

## 2. Task 분류와 모델 배분

Task를 아래 세 가지로 분류하면 어떤 모델을 쓸지 자연스럽게 결정된다.

| Task 유형 | 설명 | 적합한 접근 |
|-----------|------|-------------|
| **도메인 문해** | 설계, 아키텍처 결정, 복잡한 비즈니스 로직 | 고성능 모델 (Opus 4.6 등) |
| **반복 자동화** | Skills 기반 코드 생성, 테스트, 빌드 | 저렴한 경량 모델 |
| **비반복 build & test** | 새 기능 개발 + 검증 | 자동 모델 선정 + Skills 조합 |

### 실전 구분 기준

> "이 작업을 다음에 또 할 가능성이 있는가?"

- **예** → 반복 자동화 Task → Skills화 → 경량 모델로
- **아니오, 복잡한 판단 필요** → 도메인 문해 Task → 고성능 모델로
- **아니오, 새 기능** → 비반복 build & test → Auto 모드

---

## 3. Skills 설계 원칙

Skills는 단순한 프롬프트가 아니다. **저렴한 모델이 고품질 출력을 낼 수 있게 만드는 설계**가 핵심이다.

### Skills의 3요소

```
Skills
├── 컨텍스트 압축     — 모델이 알아야 할 도메인 지식 요약
├── 출력 형식 정의    — 예상 출력 구조 명시 (JSON, 코드 블록 등)
└── 제약 조건 명시    — 사용 기술 스택, 금지 패턴, 코딩 컨벤션
```

### Skills 문서 예시

```markdown
# Skills: FastAPI CRUD 생성

## 컨텍스트
- 프레임워크: FastAPI + SQLAlchemy 2.0 (async)
- 스키마: Pydantic v2 사용
- DB: PostgreSQL, Alembic 마이그레이션

## 출력 형식
- Router, Service, Schema, Model 레이어 분리
- 각 파일은 코드 블록으로 분리하여 제공

## 제약 조건
- 에러 핸들링: HTTPException + custom error schema
- 타입 힌트 100% 적용
- 테스트: pytest + httpx 비동기 패턴
```

### Skills & Like Subagents

Skills는 체험해 보시면 쉽게 이해가 되는 부분이다.
하지만 Sub Agents는 직접 세팅해서 이해하기 조금은 어려운 부분이 있다.
커서 기준으로는 요금제가 특정 이상이 되어야 서브에이전트를 체험해 볼 수 있다.

서브에이전트는 결국 여러 에이전트가 일을 알아서 하기 위한 조건이며,
대표적인 사례로는 opencode의 플러그인인 **oh-my-opencode**의 핵심 개념을 체험해 보면
서브에이전트의 위력을 느낄 수 있다.

우선 위 내용은 각 툴 세팅에서 언급하기로 하고,
위에서 **Like Subagents** 라는 용어를 사용했다. 이것은 공식 용어가 아닌 필자가 만든 시맨틱한 개념이다.
Subagent의 장점 중 하나는 **병렬 처리**를 한다는 것인데,
Skills에 병렬 처리가 가능하도록 하는 방식이 있다. 이것을 Like Subagents라고 의미를 부여한 것이다.

**실전 사례:**

Task 하위에 SDD를 이용한 지침서 `.md` 파일이 만들어졌다라고 하자.
이 상태에서 특정 도메인에 대한 개발을 부여받았다고 하자.

아래의 절차대로 진행한다.

1. `@000.md` 파일을 참고해서 `@prd-step-md-worker` 스킬로 문서 작성해
   - 여기서 저 스킬은 `.md` 파일을 참고해서 세부 PRD `.md` 파일을 만들라는 스킬이다.
2. 위 1번으로 해당 폴더 내 `work_1`과 같은 폴더 하위에 10개의 파일을 만들었다고 가정하자
   - `@work_1` 폴더 하위의 파일들을 참고해서 `@work-step-worker` 스킬로 병렬로 구현해

즉 **1번은 Skills**, **2번은 Like Subagents**처럼 작동된다.
물론 병렬 처리되는 문서끼리는 모델이 알아서 병렬 처리하고, 선행되어야 하는 파일들은 동기 처리한다.

---

## 4. 도메인 경계 설정 방법

세션을 전환하면 모델의 컨텍스트가 리셋된다. **도메인 경계를 잘 잡아두면 세션 복원이 빠르다.**

### 도메인 분리 기준

1. **독립 배포 가능한가?** — 분리 가능하면 별도 도메인
2. **다른 도메인에 영향 없이 수정 가능한가?** — 가능하면 좋은 경계
3. **하나의 세션에서 완결되는가?** — 세션 단위와 도메인 단위를 맞추면 효율적

### 도메인 컨텍스트 저장

도메인 설계가 끝나면 반드시 문서화하여 세션 전환 후에도 복원 가능하게 한다.

```bash
# 추천 저장 위치
.cursorrules              # Cursor 자동 로드
CLAUDE.md                 # Claude Code 자동 로드
skills/{domain}.md        # Opencode 수동 로드
```

AGENTS.md 와 같이 여러 툴들을 공통화 하려는 흐름이 있지만
툴마다 `.cursor` 과 같이 특정 폴더를 사용하는 경우도 있습니다.
`.agents` 로 대부분 통일되는 흐름이 있습니다.

:::tip 세션 전환 전 체크
새 세션을 열기 전에 현재 도메인의 주요 결정사항, 사용 기술, 미완성 Task를 해당 문서에 업데이트하라.
다음 세션 첫 프롬프트에 이 문서를 첨부하면 컨텍스트 복원에 드는 시간을 크게 줄일 수 있다.
:::

---

## 5. Skills화의 경제학

Skills를 만드는 데 처음에 시간이 들지만, 두 번째 실행부터는 이익이다.

```
Skills 미적용: 매번 고성능 모델 + 상세 지시 → 비용↑, 시간↑
Skills 적용:   경량 모델 + Skills 자동 로드   → 비용↓, 시간↓, 품질 일관
```

**Skills는 일종의 투자다.** 반복 빈도가 높은 작업일수록 먼저 Skills화하라.

---

## 6. Skills와 하니스(Harness) 전략

사실상 Skills는 에이전트가 어떠한 범위 내에서 어떻게 일할까를 자연어로 정의하는 문서에 가깝습니다.
이에 [skills.sh](https://skills.sh) 사이트와 같이 우후죽순 Skills 관련 사이트들이 늘고 있습니다.

물론 에이전트의 힘은 이제 저 Skills를 얼마나 잘 만드느냐에 따라 차이가 있는 게, 지금 현 시점에서는 핵심입니다.

:::danger 검증되지 않은 Skills 주의
검증되지 않은 스킬들을 복사 붙여넣기로 운용하시는 것은 **절대 반대**합니다.
문서 내에 악성코드 격의 내용들을 적어 넣고 보안에 취약한 사례들이 나오고 있습니다.
:::

따라서, **검증된 스킬 몇 개만 선정해서 공식 스킬 사용**.
가능하면 우리 회사만의 스킬들만 만들어서 공유하는 것을 권장합니다.

이것이 결국은 최종적으로 말씀드릴 **하니스(Harness) 기법**으로 가기 위한 초석입니다.
현 시점(2026.2)에서는 프롬프트, Tools가 아닌
Skills, Sub Agents — 이러한 것들을 묶어서 우리만의 세트로 만들어두는 **하니스 기법**이 대세입니다.

---

## 7. 디지로그랩스만의 방법

아래 화면은 **DDD(Domain Driven Development) 기법**과 **SDD(Spec Driven Development) 기법**을
Electron Desktop 프로그램으로 구현한 사례이다.

위에서 설명한 도메인별 지침 문서를 만들고, opencode를 이용해서 위에 설명한
**Skills + Like Subagents**를 작동시킴으로써 자동으로 구현을 처리하는 프로그램이다.

![DDD Studio 01](./img/01.jpg)
![DDD Studio 02](./img/02.jpg)
![DDD Studio 03](./img/03.jpg)
![DDD Studio 04](./img/04.jpg)
![DDD Studio 05](./img/05.jpg)
